

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Package structure and state</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="../_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="../_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/mystnb.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .secondtoggle, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Testing" href="04-testing.html" />
    <link rel="prev" title="The Whole Game" href="02-the-whole-game.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/py-pkgs-hex.png" class="logo" alt="logo">
  
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  
  <ul class="nav sidenav_l1">
  <li class="">
    <a href="01-setup.html">1. System Setup</a>
  </li>
  <li class="">
    <a href="02-the-whole-game.html">2. The Whole Game</a>
  </li>
  <li class="active">
    <a href="">3. Package structure and state</a>
  </li>
  <li class="">
    <a href="04-testing.html">4. Testing</a>
  </li>
  <li class="">
    <a href="05-documentation.html">5. Documentation</a>
  </li>
</ul>
</nav>

 <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse" data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu" aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation" title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
            <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i class="fas fa-download"></i></button>

            
            <div class="dropdown-buttons">
                <!-- ipynb file if we had a myst markdown file -->
                
                <!-- Download raw file -->
                <a class="dropdown-buttons" href="../_sources/content/03-package-structure.ipynb.txt"><button type="button" class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip" data-placement="left">.ipynb</button></a>
                <!-- Download PDF via print -->
                <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF" onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
            </div>
            
        </div>

        <!-- Source interaction buttons -->
        

        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->
        
    </div>
    <div class="d-none d-md-block col-md-2 bd-toc show">
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#package-states" class="nav-link">Package States</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#modules" class="nav-link">Modules</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#python-packages" class="nav-link">Python packages</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#source-distribution-packages" class="nav-link">Source distribution packages</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#built-distribution-packages" class="nav-link">Built distribution packages</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#binary-distribution-packages" class="nav-link">Binary distribution packages</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#poetry-and-pyproject-toml" class="nav-link">Poetry and pyproject.toml</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#installed-packages" class="nav-link">Installed packages</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#imported-packages" class="nav-link">Imported Packages</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#packaging-python-applications" class="nav-link">Packaging Python Applications</a>
        </li>
    
    </ul>
</nav>


    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="package-structure-and-state">
<span id="package-structure"></span><h1>Package structure and state<a class="headerlink" href="#package-structure-and-state" title="Permalink to this headline">¶</a></h1>
<p>The previous chapter demonstrated how to develop a Python package from scratch with the help of <a class="reference external" href="https://python-poetry.org/">poetry</a>. This chapter now takes a more in-depth look at packaging in Python. Often, developers don’t think about packaging until their code is actually written - but we’ll learn that thinking about packaging before even writing any code is very useful! This chapter is a somewhat Pythonified version of the <a class="reference external" href="https://r-pkgs.org/whole-game.html">Package Structure and State chapter</a> of the <a class="reference external" href="https://r-pkgs.org/">R Packages book</a> written by Jenny Bryan and also draws on information from the <a class="reference external" href="https://www.pypa.io/en/latest/">Python Packaging Authority</a>.</p>
<div class="section" id="package-states">
<span id="id1"></span><h2>Package States<a class="headerlink" href="#package-states" title="Permalink to this headline">¶</a></h2>
<p>By “package” here we mean the code that you wish to bundle up and distribute. In Python, your package can be in several different states depending on its complexity, target audience, and stage of development. The ones we’ll talk about here are:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#python-modules"><span class="std std-ref">Modules</span></a></p></li>
<li><p><a class="reference internal" href="#python-packages"><span class="std std-ref">Python packages</span></a></p></li>
<li><p><a class="reference internal" href="#source-distributions"><span class="std std-ref">Source distribution packages</span></a></p></li>
<li><p><a class="reference internal" href="#built-distributions"><span class="std std-ref">Built distribution packages</span></a></p></li>
<li><p><a class="reference internal" href="#binary-distributions"><span class="std std-ref">Binary distribution packages</span></a></p></li>
<li><p><a class="reference internal" href="#python-poetry"><span class="std std-ref">Poetry and pyproject.toml</span></a> (not a “package state” but a useful tool for building/installing/managing different states)</p></li>
<li><p><a class="reference internal" href="#installed-packages"><span class="std std-ref">Installed packages</span></a></p></li>
<li><p><a class="reference internal" href="#imported-packages"><span class="std std-ref">Imported Packages</span></a></p></li>
<li><p><a class="reference internal" href="#python-applications"><span class="std std-ref">Packaging Python Applications</span></a></p></li>
</ul>
<p>You’ve already seen some of the commands that put packages into these various states. For example, <code class="docutils literal notranslate"><span class="pre">poetry</span> <span class="pre">build</span></code> at the CL or <code class="docutils literal notranslate"><span class="pre">import</span></code> in a Python session. In the following sections, we’ll be giving those operations some context.</p>
<div class="figure align-default" id="package-flowchart">
<a class="reference internal image-reference" href="../_images/package-flowchart.png"><img alt="../_images/package-flowchart.png" src="../_images/package-flowchart.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 12 </span><span class="caption-text">The Python packaging workflow.</span><a class="headerlink" href="#package-flowchart" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="modules">
<span id="python-modules"></span><h2>Modules<a class="headerlink" href="#modules" title="Permalink to this headline">¶</a></h2>
<p>A module is any Python <code class="docutils literal notranslate"><span class="pre">.py</span></code> file. A module may consist of Python functions, classes, variables, and/or runnable code. A module that relies <em>only</em> on the standard Python library can easily be distributed and used by others (on the appropriate version of Python). In this way, a module can be thought of as a very simple package. For example, consider a module <code class="docutils literal notranslate"><span class="pre">simple_math.py</span></code> that contains the functions <code class="docutils literal notranslate"><span class="pre">list_range</span></code> and <code class="docutils literal notranslate"><span class="pre">odd_even</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">list_range</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  
<span class="k">def</span> <span class="nf">odd_even</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x is odd.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x is even.&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>If the module <code class="docutils literal notranslate"><span class="pre">simple_math.py</span></code> is in your working directory then you can import the module using:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">simple_math</span>  <span class="c1"># imports the entire module. Functions can then be accessed via dot notation, e.g., simple_math.list_range()</span>
<span class="kn">from</span> <span class="nn">simple_math</span> <span class="kn">import</span> <span class="n">list_range</span>  <span class="c1"># import only list_range function</span>
<span class="kn">from</span> <span class="nn">simple_math</span> <span class="kn">import</span> <span class="n">odd_even</span>  <span class="c1"># import only odd_even function</span>
<span class="kn">from</span> <span class="nn">simple_math</span> <span class="kn">import</span> <span class="o">*</span>  <span class="c1"># import all functions</span>
</pre></div>
</div>
<p>Because modules are single files they can easily be shared to others by e.g., email, GitHub, Slack, etc. Another user would simply place the module in their working directory to use it. However, this method of distribution does not scale well in cases of multiple files, if your code depends on other libraries/packages, or needs a specific version of Python.</p>
</div>
<div class="section" id="python-packages">
<span id="id2"></span><h2>Python packages<a class="headerlink" href="#python-packages" title="Permalink to this headline">¶</a></h2>
<p>Projects consisting of multiple Python <code class="docutils literal notranslate"><span class="pre">.py</span></code> files (i.e., modules) are, by their nature, harder to distribute. If your project consists of multiple files, it is typical to organise it into a directory structure. Any directory containing Python files can comprise a Python “package”.</p>
<p>While we’ve been using the term “package” generically so far, it does have a specific meaning in Python and it’s important to make clear the distinction between “modules” and “packages”. As described in the previous section, any Python <code class="docutils literal notranslate"><span class="pre">.py</span></code> file is a module. In contrast, a package is a directory containing module(s) and/or additional package(s) (sometimes called “nested packages” or “subpackages”) along with an <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> file. An <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> file is required to make Python treat a directory as a package (as opposed to it simply being a plain-old directory of Python files); in the simplest case <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> is an empty file, but it can also execute initialization code for the package upon import (read more <a class="reference external" href="https://docs.python.org/3/tutorial/modules.html#importing-from-a-package">here</a>). Packages allow us to structure and organise our Python code and intuitively access it using “dotted module names”. Consider having the following two packages in your working directory:</p>
<p>A package containing modules:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pkg1
├── __init__.py
├── simple_math.py
└── advanced_math.py
</pre></div>
</div>
<p>A package containing nested packages:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pkg2
├── __init__.py
├── simple
│   ├── __init__.py
│   └── simple_math.py
├── advanced
    ├── __init__.py
    └── advanced_math.py
</pre></div>
</div>
<p>Modules can be accessed using dot notation. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pkg1</span> <span class="kn">import</span> <span class="n">simple_math</span>  <span class="c1"># import simple_math module from pkg1</span>
<span class="kn">from</span> <span class="nn">pkg2.simple</span> <span class="kn">import</span> <span class="n">simple_math</span>  <span class="c1"># import simple_math module from pkg2</span>
</pre></div>
</div>
<p>It would be possible to share a package by transferring all the files that comprise the package (keeping the directory structure intact) to another user, who could then use the package if it were placed in their working directory. However, just like single modules, this method of distribution does not scale well, makes it difficult to support or update your code, and won’t work if your code depends on additional libraries, or needs a specific version of Python. We need a more efficient and reliable way to package and distribute our code which leads us to “source distribution packages” and “built distribution packages” which are described below.</p>
</div>
<div class="section" id="source-distribution-packages">
<span id="source-distributions"></span><h2>Source distribution packages<a class="headerlink" href="#source-distribution-packages" title="Permalink to this headline">¶</a></h2>
<p>A “distribution package” (often referred to simply as a “distribution”) is a single archive of the Python packages, modules and other files that make up your project. Having a single archive makes it easier to distribute your code to the world. The fundamental distribution format is called a “source distribution” (<code class="docutils literal notranslate"><span class="pre">sdist</span></code>). An <code class="docutils literal notranslate"><span class="pre">sdist</span></code> is a compressed archive (e.g., <code class="docutils literal notranslate"><span class="pre">.tar.gz</span></code> or <code class="docutils literal notranslate"><span class="pre">.zip</span></code>) of your package. Essentially, an <code class="docutils literal notranslate"><span class="pre">sdist</span></code> provides all of the metadata and source files needed for building and installing your package You can read more about source distributions <a class="reference external" href="https://docs.python.org/3/distutils/sourcedist.html">here</a>. The standard tool in Python for creating <code class="docutils literal notranslate"><span class="pre">sdists</span></code> (and binary distributions, which we’ll explore in the next section) is <code class="docutils literal notranslate"><span class="pre">setuptools</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As we saw in <a class="reference internal" href="02-the-whole-game.html#whole-game"><span class="std std-ref">The Whole Game</span></a>, we prefer to use Poetry to create distribution packages of our Python code, as a simpler and more intuitive alternative to <code class="docutils literal notranslate"><span class="pre">setuptools</span></code>. We’ll discuss Poetry in <a class="reference internal" href="#python-poetry"><span class="std std-ref">Poetry and pyproject.toml</span></a>).</p>
</div>
<p>As a very simple example, consider the following directory which now contains a <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> file.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>root
├── pkg1
│   ├── __init__.py
│   ├── simple_math.py
│   └── advanced_math.py
└── setup.py
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> file is a standard file that contains metadata about your project and helps <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> build your <code class="docutils literal notranslate"><span class="pre">sdist</span></code> - in the very simplest case, it may look like this:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>from distutils.core import setup


setup<span class="o">(</span><span class="nv">name</span><span class="o">=</span><span class="s1">&#39;pkg1&#39;</span>,
      <span class="nv">version</span><span class="o">=</span><span class="s1">&#39;0.1.0&#39;</span>,
      <span class="nv">packages</span><span class="o">=[</span><span class="s1">&#39;pkg1&#39;</span><span class="o">]</span>,
      <span class="o">)</span>
</pre></div>
</div>
<p>We won’t talk about <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> anymore here as we will advocate for using poetry for building and distributing your packages (we’ll get to that in <a class="reference internal" href="#python-poetry"><span class="std std-ref">Poetry and pyproject.toml</span></a>, but if you see a <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> file somewhere at least you now know what it’s for! If you want to learn more about creating a <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> file, it is described in detail <a class="reference external" href="https://docs.python.org/3/distutils/setupscript.html">here</a>. If you did decide to use <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> for building your package and you have your <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> file all set up, your <code class="docutils literal notranslate"><span class="pre">sdist</span></code> can be built by changing to the <code class="docutils literal notranslate"><span class="pre">root</span></code> directory of your package and running the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ python setup.py sdist
</pre></div>
</div>
<p>This will create an archive file (<code class="docutils literal notranslate"><span class="pre">.tar.gz</span></code> by default) of your project which is your <code class="docutils literal notranslate"><span class="pre">sdist</span></code>. If your code is pure Python then an <code class="docutils literal notranslate"><span class="pre">sdist</span></code> is a perfectly acceptable way to distribute your code, and a user could install it using:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ python setup.py install
</pre></div>
</div>
<p>You could also share your <code class="docutils literal notranslate"><span class="pre">sdist</span></code> to PyPI from which a user could install it using <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span></code>. It’s important to note that installing a package actually adds the package to your default installation directory (more on that in <a class="reference internal" href="#installed-packages"><span class="std std-ref">Installed packages</span></a>) such that it is accessible outside of your working directory - this is a key difference to simply sharing code as a module or package as we explored in the last two sections. We recommend consulting the <a class="reference external" href="https://the-hitchhikers-guide-to-packaging.readthedocs.io/en/latest/creation.html">The Hitchhiker’s Guide to Packaging</a> and the <a class="reference external" href="https://docs.python.org/3/distutils/sourcedist.html">Python docs</a> for more information on creating and distributing source distributions. Some notable examples of Python <code class="docutils literal notranslate"><span class="pre">sdists</span></code> include: <a class="reference external" href="https://github.com/django/django">Django</a>, <a class="reference external" href="https://github.com/python-hyper/hyperlink">hyperlink</a>, and <a class="reference external" href="https://github.com/psf/requests">requests</a>.</p>
</div>
<div class="section" id="built-distribution-packages">
<span id="built-distributions"></span><h2>Built distribution packages<a class="headerlink" href="#built-distribution-packages" title="Permalink to this headline">¶</a></h2>
<p>Source distributions are “unbuilt” and require a build step before they can be installed. This nuance is most relevant in cases where your code relies on non-Python code/libraries that require building (aka “compilation”) before they can be used (more on that in <a class="reference internal" href="#binary-distributions"><span class="std std-ref">Binary distribution packages</span></a>)). However, even if your package is written in pure Python, a build step is still required to build out the installation metadata. As a result, built distributions are the preferred format for distributing your Python packages. They are packages that have been pre-built and do not require a build step before installation - they only need to be moved to the correct location on your system (as we’ll explore more in <a class="reference internal" href="#installed-packages"><span class="std std-ref">Installed packages</span></a>)). Like a source distribution, a built distribution is a single artefact, and the main built distribution format used by Python is called a <code class="docutils literal notranslate"><span class="pre">wheel</span></code>.</p>
<p>Python’s installer <code class="docutils literal notranslate"><span class="pre">pip</span></code> always prefers installing built distributions (<code class="docutils literal notranslate"><span class="pre">wheels</span></code>) over source distributions (<code class="docutils literal notranslate"><span class="pre">sdists</span></code>) because installation is faster. Building <code class="docutils literal notranslate"><span class="pre">wheels</span></code> is similar to building source distributions with <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> as described in the previous section. We won’t go into details here because for most users we recommend the use of Python poetry (described later in <a class="reference internal" href="#python-poetry"><span class="std std-ref">Poetry and pyproject.toml</span></a>)) which handles this build process for you in a simple and intuitive way. However, if you’re interested in learning more about using <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> to build a <code class="docutils literal notranslate"><span class="pre">wheel</span></code> of your project we recommend taking a look at the <a class="reference external" href="https://packaging.python.org/tutorials/packaging-projects/">Python Packaging User Guide tutorial</a>.</p>
<p>If your code relies on any non-Python code/libraries, you’ll need to use a specific kind of built distribution known as a binary distribution to bundle up your package, which is described in the next section.</p>
</div>
<div class="section" id="binary-distribution-packages">
<span id="binary-distributions"></span><h2>Binary distribution packages<a class="headerlink" href="#binary-distribution-packages" title="Permalink to this headline">¶</a></h2>
<p>One of the most powerful features of Python is its ability to interoperate with libraries written in other languages, for example, C. Developers sometimes choose to take advantage of this interoperability and include code from other languages in their package to make their code faster, access libraries written in other languages, and generally improve the functionality of their code. While Python is typically referred to as an interpreted language (i.e., your Python code is translated to machine code as it is executed), languages such as C require compilation before they can be used (i.e., your code must be translated into “machine code” <em>before</em> it can be executed). Most end-users will probably not have the tools, experience, or time to build packages containing code written in other languages (typically called “extensions”), so in these cases binary distributions are how you make life as easy as possible for installers of your code. Binary distribution packages are simply packages that contains pre-compiled extensions - as an analogy, you can think of your source code as a cake recipe, while a binary distribution is the fully cooked cake.</p>
<p>For example, much of the commonly used Python library <code class="docutils literal notranslate"><span class="pre">NumPy</span></code> is implemented as C extensions. The existence of pre-built <code class="docutils literal notranslate"><span class="pre">wheels</span></code> in Python means that a user can, for example, simply run <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">numpy</span></code> to install <code class="docutils literal notranslate"><span class="pre">NumPy</span></code> from PyPi, as opposed to having to build it from source with the help of a C compiler, amongst other requirements. If you’re feeling particularly masochistic you can actually try to build <code class="docutils literal notranslate"><span class="pre">NumPy</span></code> from source following <a class="reference external" href="https://numpy.org/devdocs/user/building.html">these instructions from the <code class="docutils literal notranslate"><span class="pre">NumPy</span></code> docs</a>.</p>
<p>Recall that binary distributions contain compiled code (code that has been translated from human-readable form to machine code), but different platforms (i.e., Windows, Mac, Linux) read machine code differently. As a result, binary distributions are platform specific. For this reason, binary distributions are usually provided with their corresponding source distributions; if you don’t upload binary <code class="docutils literal notranslate"><span class="pre">wheels</span></code> of your code for every platform, end-users will still be able to build it from source. Take a look at the downloadable file list of <a class="reference external" href="https://pypi.org/project/numpy/#files"><code class="docutils literal notranslate"><span class="pre">NumPy</span></code> on PyPi</a> - you’ll see <code class="docutils literal notranslate"><span class="pre">wheels</span></code> for most common platforms, as well as the source distribution at the bottom of the list. <code class="docutils literal notranslate"><span class="pre">wheels</span></code> actually come in three flavours (which you can read more about <a class="reference external" href="https://packaging.python.org/guides/distributing-packages-using-setuptools/#wheels">here</a>):</p>
<ol class="simple">
<li><p><em>Universal wheels</em>: pure Python and support Python 2 and 3. Can be installed anywhere using <code class="docutils literal notranslate"><span class="pre">pip</span></code>.</p></li>
<li><p><em>Pure Python wheels</em>: pure Python but don’t support both Python 2 and 3</p></li>
<li><p><em>Platform wheels</em>: binary package distributions specific to certain platforms as a result of containing compiled extensions.</p></li>
</ol>
<p>You can tell a lot about a <code class="docutils literal notranslate"><span class="pre">wheel</span></code> from the name itself which follows a <a class="reference external" href="https://www.python.org/dev/peps/pep-0427/#file-name-convention">strict naming convention</a>: <code class="docutils literal notranslate"><span class="pre">{distribution}-{version}(-{build</span> <span class="pre">tag})?-{python</span> <span class="pre">tag}-{abi</span> <span class="pre">tag}-{platform</span> <span class="pre">tag}.whl.</span></code>. For example, the <code class="docutils literal notranslate"><span class="pre">NumPy</span></code> wheel <code class="docutils literal notranslate"><span class="pre">numpy-1.18.1-cp37-cp37m-macosx_10_9_x86_64.whl</span></code> tells us that:</p>
<ul class="simple">
<li><p>The distribution is <code class="docutils literal notranslate"><span class="pre">NumPy</span> <span class="pre">v1.18.1</span></code>;</p></li>
<li><p>It is made for Python 3.7;</p></li>
<li><p>It is specific to the <code class="docutils literal notranslate"><span class="pre">macosx_10_9_x86_64</span></code> platform (i.e, this is a “platform wheel” because it is platform-specific).</p></li>
</ul>
<p>Most Readers will never deal with building extensions in other languages for their Python package, so this section is intended to be read as general information on Python’s packaging ecosystem and the <code class="docutils literal notranslate"><span class="pre">wheel</span></code> format. However, if you are interested in building binary extensions for your package, the <a class="reference external" href="https://packaging.python.org/guides/packaging-binary-extensions/">Python Packaging Authority guide</a> is a good place to start.</p>
</div>
<div class="section" id="poetry-and-pyproject-toml">
<span id="python-poetry"></span><h2>Poetry and pyproject.toml<a class="headerlink" href="#poetry-and-pyproject-toml" title="Permalink to this headline">¶</a></h2>
<p>The previous sections gave a high level overview of Python’s standard packaging options and tools. However, in <a class="reference internal" href="02-the-whole-game.html#whole-game"><span class="std std-ref">The Whole Game</span></a> we used Poetry to create a toy Python package - so where does this fit into the Python packaging landscape? Well, in the previous sections on <a class="reference internal" href="#source-distributions"><span class="std std-ref">Source distribution packages</span></a> and <a class="reference internal" href="#built-distributions"><span class="std std-ref">Built distribution packages</span></a>, we really only touched the tip of the iceberg of Python packaging. When creating a package there’s a lot of customisation to think about with your <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> file, and a host of other files we didn’t even talk about (e.g., <code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code>, <code class="docutils literal notranslate"><span class="pre">setup.cfg</span></code>, etc)! Needless to say, packaging in Python can be hard to understand, especially for beginners. These words echo the sentiments of poetry’s creator Sébastien Eustace and the motivation for creating the tool:</p>
<blockquote>
<div><p><em>“Packaging systems and dependency management in Python are rather convoluted and hard to understand for newcomers. Even for seasoned developers it might be cumbersome at times to create all files needed in a Python project: setup.py, requirements.txt, setup.cfg, MANIFEST.in, and the newly added Pipfile. So I wanted a tool that would limit everything to a single configuration file to do: dependency management, packaging and publishing.”</em></p>
</div></blockquote>
<p>That “single configuration file” is <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> (you can read more about <code class="docutils literal notranslate"><span class="pre">.toml</span></code> files <a class="reference external" href="https://www.python.org/dev/peps/pep-0518/">here</a>). Essentially, poetry is based on all the concepts of <code class="docutils literal notranslate"><span class="pre">sdists</span></code> and <code class="docutils literal notranslate"><span class="pre">wheels</span></code> discussed previously - it just simplifies and streamlines the whole packaging process in an intuitive way. In fact, the <code class="docutils literal notranslate"><span class="pre">poetry</span> <span class="pre">build</span></code> command you used in <a class="reference internal" href="02-the-whole-game.html#build-and-publish"><span class="std std-ref">Building Your Package and Publishing to testPyPI</span></a>, actually creates the <code class="docutils literal notranslate"><span class="pre">sdist</span></code> and <code class="docutils literal notranslate"><span class="pre">wheel</span></code> distributions of your package for you (depending on how you’ve configured your project). It really is simple to create and distribute Python packages with poetry - go back and check out <a class="reference internal" href="02-the-whole-game.html#whole-game"><span class="std std-ref">The Whole Game</span></a> for our recommended workflow, or check out the <a class="reference external" href="https://python-poetry.org/docs/">poetry docs</a>.</p>
<div class="figure align-default" id="id3">
<a class="reference internal image-reference" href="../_images/python-packages.png"><img alt="../_images/python-packages.png" src="../_images/python-packages.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 13 </span><span class="caption-text">Python packaging gamut. Modified after <a class="reference external" href="https://www.youtube.com/watch?v=iLVNWfPWAC8">The Packaging Gradient by Mahmoud Hashemi</a>.</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="installed-packages">
<span id="id4"></span><h2>Installed packages<a class="headerlink" href="#installed-packages" title="Permalink to this headline">¶</a></h2>
<p>An installed package is a distribution that’s been decompressed, built (in the case of an <code class="docutils literal notranslate"><span class="pre">sdist</span></code>) and then copied to your chosen installation directory. The default “chosen installation directory” varies by platform and by how you installed Python. For example, I installed Python using the <a class="reference external" href="https://docs.conda.io/en/latest/miniconda.html">miniconda</a> distribution and my default directory for package installation is <code class="docutils literal notranslate"><span class="pre">/Users/tbeuzen/miniconda3/lib/python3.7/site-packages</span></code>.</p>
<p>“Installing” a package (e.g., by <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">XXX</span></code>) is really a two-step process: 1) building the package, and 2) installing the package. Using <code class="docutils literal notranslate"><span class="pre">wheels</span></code> takes out the first step, meaning we only need to install. The install step is simple, all it really has to do is copy all the decompressed files to the appropriate directory. In fact, we can manually install a package ourselves if we want to by manually decompressing a <code class="docutils literal notranslate"><span class="pre">wheel</span></code> and copying the files to their appropriate locations - there’s no real reason to do this because it’s far more effort than using a single one-liner at the CL, it does not resolve dependencies so could break your installation, and probably has other unwanted side-effects. However, it’s a nice way to learn about the package installation process, so if you’d like to give it a go, you can try the following steps (which are based on  MacOS and the <a class="reference external" href="https://docs.conda.io/en/latest/"><code class="docutils literal notranslate"><span class="pre">conda</span></code> package manager</a>):</p>
<ol class="simple">
<li><p>Create a new virtual environment to act as a safe, test playground. As a <code class="docutils literal notranslate"><span class="pre">conda</span></code> user, the CL command for me to create a new empty virtual environment called “manualpkg” and including Python 3.7 is <code class="docutils literal notranslate"><span class="pre">conda</span> <span class="pre">create</span> <span class="pre">--name</span> <span class="pre">manpkg</span> <span class="pre">python=3.7</span></code>. Be sure to activate the environment once it has been created (i.e., <code class="docutils literal notranslate"><span class="pre">conda</span> <span class="pre">activate</span> <span class="pre">manualpkg</span></code>);</p></li>
<li><p>You can find a toy <code class="docutils literal notranslate"><span class="pre">wheel</span></code> to download in the GitHub repository of this book <a class="reference external" href="https://github.com/UBC-MDS/py-pkgs/tree/master/docs/support/toy-pkg/dist">here</a> (although you can try this manual installation procedure with a <code class="docutils literal notranslate"><span class="pre">wheel</span></code> downloaded from any source, e.g., PyPI). Download the <code class="docutils literal notranslate"><span class="pre">wheel</span></code> into the <code class="docutils literal notranslate"><span class="pre">site-packages</span></code> directory of the <code class="docutils literal notranslate"><span class="pre">manualpkg</span></code> environment, which for me was located at <code class="docutils literal notranslate"><span class="pre">/Users/tbeuzen/miniconda3/envs/manualpkg/lib/python3.7/site-packages/</span></code>;</p></li>
<li><p>From the CL, <code class="docutils literal notranslate"><span class="pre">cd</span></code> to the <code class="docutils literal notranslate"><span class="pre">site-packages</span></code> directory of the <code class="docutils literal notranslate"><span class="pre">manualpkg</span></code> environment;</p></li>
<li><p>At this point, there is no <code class="docutils literal notranslate"><span class="pre">toy_pkg</span></code> package installed for our virtual environment to access. So starting a Python session from the CL (using <code class="docutils literal notranslate"><span class="pre">python</span></code>) and trying <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">toy_pkg</span></code> will fail because even though the <code class="docutils literal notranslate"><span class="pre">wheel</span></code> is there, we haven’t decompressed it yet;</p></li>
<li><p>From the CL we need to run <code class="docutils literal notranslate"><span class="pre">unzip</span> <span class="pre">toy_pkg-0.0.1-py3-none-any.whl</span></code>;</p></li>
<li><p>You’ll now find two fresh directories: <code class="docutils literal notranslate"><span class="pre">toy_pkg</span></code> and <code class="docutils literal notranslate"><span class="pre">toy_pkg-0.0.1.dist-info</span></code>;</p></li>
<li><p>From the CL start a Python session by typing <code class="docutils literal notranslate"><span class="pre">python</span></code> and try the following:</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">toy_pkg.toy_module</span> <span class="kn">import</span> <span class="n">test_function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_function</span><span class="p">()</span>
<span class="go">You manually installed the toy_pkg example! Well done!</span>
</pre></div>
</div>
</div>
<div class="section" id="imported-packages">
<span id="id5"></span><h2>Imported Packages<a class="headerlink" href="#imported-packages" title="Permalink to this headline">¶</a></h2>
<p>We now arrive at our last package state, the “imported package”. This state is associated with a command that is familiar to everyone that uses Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">somemodule</span>
</pre></div>
</div>
<p>You can read about the import system in detail in the <a class="reference external" href="https://docs.python.org/3/reference/import.html">Python documentation</a>. Briefly, the <code class="docutils literal notranslate"><span class="pre">import</span></code> statement comprises two operations:</p>
<ol class="simple">
<li><p>it searches for the named module; and,</p></li>
<li><p>then binds the results of that search to a name in the local namespace.</p></li>
</ol>
<p>Note that for efficiency, each module is only imported once per interpreter session. If you modify your module, you can’t just re-run your <code class="docutils literal notranslate"><span class="pre">import</span></code> statement (as that name in the namespace is already populated and won’t be re-loaded). Instead, you have to restart your interpreter or force the import using <code class="docutils literal notranslate"><span class="pre">importlib.reload()</span></code>, but this is inefficient when working with multiple modules.</p>
</div>
<div class="section" id="packaging-python-applications">
<span id="python-applications"></span><h2>Packaging Python Applications<a class="headerlink" href="#packaging-python-applications" title="Permalink to this headline">¶</a></h2>
<p>In this chapter we’ve only talked about packaging and distributing reusable Python code, a process which is really aimed at developers and audiences familiar with Python. While it’s outside the scope of this book, it’s also possible to package and distribute entire Python applications, that is, software that is meant to be used rather than developed on. Some good examples of Python-based applications are Sublime Text, EVE online, and Reddit. There are a lot of options available for packaging and distributing Python applications and we recommend watching the excellent talk by Mahmoud Hashemi <a class="reference external" href="https://www.youtube.com/watch?v=iLVNWfPWAC8">“The Packaging Gradient”</a> to learn more. To give you an idea of the available options, the figure below shows a summary of the different options discussed by Mahmoud for packaging Python applications.</p>
<div class="figure align-default" id="id6">
<a class="reference internal image-reference" href="../_images/python-applications.png"><img alt="../_images/python-applications.png" src="../_images/python-applications.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 14 </span><span class="caption-text">Python application packaging gamut. Modified after <a class="reference external" href="https://www.youtube.com/watch?v=iLVNWfPWAC8">The Packaging Gradient by Mahmoud Hashemi</a>.</span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></p>
</div>
</div>
</div>


              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="02-the-whole-game.html" title="previous page">The Whole Game</a>
    <a class='right-next' id="next-link" href="04-testing.html" title="next page">Testing</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Tomas Beuzen & Tiffany Timbers<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="../_static/js/index.js"></script>
    
  </body>
</html>