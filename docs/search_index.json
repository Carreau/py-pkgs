[
["index.html", "Python packages 1 Preface", " Python packages Tiffany Timbers 2020-02-11 1 Preface This book is aimed at Python intermediate users who want to package up their code to share it with their collaborators (including their future selves) and the wider Python community. It‚Äôs scope and intent is inspired by the R packages book written by Hadley Wickham and Jenny Bryan. "],
["setup.html", "2 System setup 2.1 Installing and updating Python 2.2 Setting up the RStudio IDE with Python", " 2 System setup 2.1 Installing and updating Python In order to start off on a good footing, we recommend you follow these system set-up instructions so you will run into fewer technical issues (compared to not using the same system this book was designed for). We recommend installing Python 3.7 via the Anaconda distribution, following the instructions here: https://docs.anaconda.com/anaconda/install/. If you already have installed this distribution, ensure Python, and the conda package manager is up to date by running the following commands: conda update --all Next, use conda to install Python poetry - a python package that will help us more efficiently build our Python packages: conda install -c conda-forge poetry 2.2 Setting up the RStudio IDE with Python This book will use the RStudio integrated development environment (IDE) to develop packages, although any Python IDE should work. Note - we do this because in the UBC Master of Data Science program we use both the R and Python programming languages and prefer to use an IDE that works well with both. If you would like to use the RStudio IDE we recommend installing the most recent version of the IDE from the preview site: https://rstudio.com/products/rstudio/download/preview/ and then installing R from CRAN, and the reticulate R package via install.package(\"reticulate\") from the R console inside RStudio. When installing reticulate, you will be prompted to install miniconda, if you have already installed the Anaconda distribution of Python, answer ‚Äúno‚Äù to installing miniconda at this prompt. 2.2.1 Find where Anaconda is installed on your machine 2.2.1.1 Mac OS &amp; Linux In terminal, type: which Python 2.2.1.2 Windows In the Anaconda Prompt type: where python. 2.2.2 Configuring reticulate for to use the Python REPL inside RStudio Create a file named .Rprofile in your $HOME directory that contains the following: Sys.setenv(RETICULATE_PYTHON = &quot;path_to_the_folder_containing_anaconda&#39;s_python&quot;) For me the \"path_to_the_folder_containing_anaconda's_python\" was '//anaconda3/bin/'. Restart RStudio for this to take effect. 2.2.3 Configuring the RStudio terminal 2.2.3.1 Mac OS &amp; Linux Open (or create) the file called .bash_profile in your $HOME directory and add the following to the last line of that file: export PATH=&quot;path_to_the_folder_containing_anaconda&#39;s_python:$PATH&quot; For me that line is export PATH=\"//anaconda3/bin:$PATH\". Restart RStudio for this to take effect. 2.2.3.2 Windows The default terminal in RStudio on Windows is PowerShell. This causes some unexpected problems as its not a true bash shell. You should change this using the following menu selections inside RStudio: Global Options -&gt; Terminal -&gt; Shell -&gt; Git Bash "],
["whole-game.html", "3 The Whole Game 3.1 Use Poetry to create a Python project 3.2 Put your project under version control 3.3 Write the first function", " 3 The Whole Game This chapter demonstrates how to develop an entire small toy Python package from beginning to end. It‚Äôs purpose it to motivate and give a high level overview of how a Python package can and should be developed. Later chapters will delve deeper into important package specifics. This chapter is a Pythonified version of the Whole Game chapter written by Jenny Bryan that can be found in the the R packages book. 3.1 Use Poetry to create a Python project To create a new Python project with Poetry named foo-categoricals, using the terminal navigate to the parent directory that you wish the project directory to live in and type: $ poetry new foocategoricals Created package foocategoricals in foocategoricals When we do this, Poetry creates a directory with the following structure: foocategoricals ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ foocategoricals ‚îÇ ‚îî‚îÄ‚îÄ __init__.py ‚îú‚îÄ‚îÄ pyproject.toml ‚îî‚îÄ‚îÄ tests ‚îú‚îÄ‚îÄ __init__.py ‚îî‚îÄ‚îÄ test_foocategoricals.py It gives us a boilerplate file and directory structure suitable for building a Python package, including a file for us to write out Python functions that our package will distribute (foocategoricals/__init__.py), a home for our tests to ensure that our package functions work as we expect they should (tests/__init__.py), as well as a pyproject.toml file that we will use to define our project‚Äôs metadata. Optional for RStudio IDE users Users of the RStudio IDE may also want to make this Python project directory an RStudio project. Why might you ask? Well, once you have an *.Rproj file, you can use that file to quickly open the RStudio IDE (which has a terminal and an interactive Python REPL, assuming you have set this up with reticulate) to the project‚Äôs root directory. 3.2 Put your project under version control It is in our opinion that every data science project should put under local and remote version control. The tools we recommend using for this are Git &amp; GitHub. For this book, we assume Git is installed on their machine, have novice Git skills, and that users have a GitHub.com account. 3.2.1 Set-up local version control From the terminal and in the root of this project directory, initialize the repository to be tracked by Git: $ git init Initialized empty Git repository in /Users/tiffany/Documents/ubc-mds/foocategoricals/.git/ Next, tell Git which files to track (all of them at this point) and commit these changes locally: $ git add . $ git commit -m &quot;initial project set-up&quot; [master (root-commit) 00bc4af] initial project set-up 7 files changed, 35 insertions(+) create mode 100644 .gitignore create mode 100644 README.rst create mode 100644 foocategoricals.Rproj create mode 100644 foocategoricals/__init__.py create mode 100644 pyproject.toml create mode 100644 tests/__init__.py create mode 100644 tests/test_foocategoricals.py Optional for RStudio IDE users You may want to create a .gitignore file where you tell Git to ignore RStudio-specific files such as .Rproj.user and foocategoricals.Rproj that are typically not found in a Python package. 3.2.2 Set-up remote version control Now that we have set up our local version control, let‚Äôs create a repository on GitHub.com and set that as the remote version control home for this project: The options we recommend for setting up a repository for a Python package using the workflow we present in this book include: give the GitHub.com repository the same name as your Python Poetry project‚Äôs name make the GitHub.com repository public do not initialize the GitHub.com repository with a README Next, we set-up the remote address locally, and push our project to GitHub.com: $ git remote add origin git@github.com:ttimbers/foocategoricals.git $ git push -u origin master Note: the example above uses SSH authentication with GitHub, HTTPS authentication works as well and would use this url in place of the one shown above to set the remote: https://github.com/ttimbers/foocategoricals.git. 3.3 Write the first function Pandas categoricals are a very useful datatype for modeling (and were inspired by R‚Äôs factors), but certain manipulations of this data type can be tricky in data wrangling. One such challenge is concatenation of Pandas categoricals. Let‚Äôs observe the result of trying to concatenate two Pandas categoricals objects: import pandas as pd a = pd.Categorical([&quot;character&quot;, &quot;hits&quot;, &quot;your&quot;, &quot;eyeballs&quot;]) b = pd.Categorical([&quot;but&quot;, &quot;integer&quot;, &quot;where it&quot;, &quot;counts&quot;]) pd.concat([a, b]) ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: cannot concatenate object of type &#39;&lt;class &#39;pandas.core.arrays.categorical.Categorical&#39;&gt;&#39;; only Series and DataFrame objs are valid This occurs because the categoricals are represented as integers in memory, and in a the integer 0 corresponds to the word ‚Äúcharacter‚Äù while in b, the integer 0 corresponds to the word ‚Äúbut‚Äù. Thus, when we ask Python to concatenate these two Pandas categorical options it doesn‚Äôt know what to do with these integer mappings to different categories, and so it throws an error. We can get around this several ways, one way is to convert the Pandas categoricals to a str type, then do the concatenation, and finally convert the concatenated Pandas obeject to a categorical again. We demonstrate that approach below: concatenated = pd.concat([pd.Series(a.astype(&quot;string&quot;)), pd.Series(b.astype(&quot;string&quot;))]) pd.Categorical(concatenated) ## [character, hits, your, eyeballs, but, integer, where it, counts] ## Categories (8, object): [but, character, counts, eyeballs, hits, integer, where it, your] That seems to work üéâ, but its quite a bit of typing everytime we want to do this‚Ä¶ Let‚Äôs turn this into a function called catbind! def catbind(a, b): concatenated = pd.concat([pd.Series(a.astype(&quot;string&quot;)), pd.Series(b.astype(&quot;string&quot;))]) return pd.Categorical(concatenated) Note - this book assumes you know how to write, document and test functions in Python. To learn more about this see Think Python, Chapter 3: Functions by Allen Downey. Where do we save this function if we want it to be a part of our foocategorical Python package? Let‚Äôs review the landscape of our Python project so far: foocategoricals ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ foocategoricals ‚îÇ ‚îî‚îÄ‚îÄ __init__.py ‚îú‚îÄ‚îÄ pyproject.toml ‚îî‚îÄ‚îÄ tests ‚îú‚îÄ‚îÄ __init__.py ‚îî‚îÄ‚îÄ test_foocategoricals.py All the code that we would like the user to run as part of our package should live inside the foocategoricals directory. Typically, inside this directory, we would create a sub-directory containing a python script to house the function. Let‚Äôs do that now: First we create a subdirectory inside foocategoricals called cat using mkdir in the terminal: $ mkdir foocategoricals/cat Note: mkdir is a command in the bash shell that we can use to create new directories. You are welcome to create directories using the RStudio IDE, or your computer‚Äôs OS if you prefer that workflow. Next we create a python script called cat.py that lives inside the cat directory and save our catbind function there. Our project directory structure should now look like this: foocategoricals ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ foocategoricals ‚îÇ ‚îú‚îÄ‚îÄ __init__.py | ‚îî‚îÄ‚îÄ cat | ‚îú‚îÄ‚îÄ cat.py ‚îú‚îÄ‚îÄ pyproject.toml ‚îî‚îÄ‚îÄ tests ‚îú‚îÄ‚îÄ __init__.py ‚îî‚îÄ‚îÄ test_foocategoricals.py Now, inside foocategoricals/__init__.py we need to add one line of Python code (below the line of code that Poetry wrote there when we set up the project, which is something like __version__ = '0.1.0') to import the catbind function from cat.py: from cat.cat import catbind TO DO: deal with Pandas dependency "]
]
