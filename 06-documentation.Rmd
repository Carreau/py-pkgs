# Documentation {#documentation}

```{r setup-documentation, include = FALSE}
options(prompt = '>>> ')
options(continue = '>>> ')
```

Documentation is one of the most important aspects of a good package. For the users of your code (including your future self) it is necessary to have readable and accessible documentation expressing what your pakcage does, how to install your package, and how to use the user-facing functions within it. Section [2.6 Package documentation](#pkg-docs) in [The Whole Game chapter](#whole-game) briefly introduced documentation in Python package development. This chapter now describes in more detail how to document your package. This chapter is inspired by [the Object documentation](https://r-pkgs.org/man.html) chapter of the [R packages book](https://r-pkgs.org/).

https://docs.python-guide.org/writing/documentation/

## Package documentation {#pkg-documentation}

Your project as a whole should have a few key pieces of documentation that describe your package, how it can be used, and how to develop it. Typically, these more "high-level" pieces of documentation are located in the package's root directory and include:

- README
- License
- Conduct (optional)
- Contributors (optional)
- Contributing (optional)

Each of these files are described in more detail below. Note that the Cookiecutter template described and used in Section [2.1 Use Cookiecutter & Poetry to create a Python project](#pkg-docs) of [The Whole Game chapter](#whole-game) automatically creates and fills out these files for you.

**README**

The README file is perhaps the most important piece of documentation in your package and provides a general overview of your package. The README typically includes, in order:

- The package name.
- Any relevant badges (e.g., for continuous integration, test coverage, peer-review, hosted documentation, etc.). [Here](https://shields.io/) is a useful website for exploring badges.
- A short description of the aims of the package.
- Installation instructions.
- Brief demonstration of usage.
- Direction to more detailed documentation (more on this below).
- Credits/citations.

**License**

All packages should include a license file. A license tells others what they can and can't do with your code. You don't have to include a license, however, if you choose not to, then default copyright laws apply which means that you retain all rights to your source code and no one may reproduce, distribute, or create derivative works from your work - this is obviously not conducive to open-source work! The [Open Source Initiative (OSI)](https://opensource.org/) is a good place to learn more about different licenses and GitHub also has a [useful tool](https://choosealicense.com/) for helping you choose the most appropriate license for your package.

**Conduct/Contributors/Contributing (optional)**

These files (and others) are optional inclusions to your project but help to define, protect and promote your work in the open-source world. Breifly, a *conduct file* is used to define community standards, identify a welcoming and inclusive project, and outline procedures for handling abuse. GitHub provides a [good guide](https://help.github.com/en/github/building-a-strong-community/adding-a-code-of-conduct-to-your-project) for adding a code of conduct to your project. A *contributors file* can be used to clearly idenitfy project contributors (although you may choose to include this in your README file instead). A *contributing file* simply outlines procedures for how users can efficiently and helpfully contribute to your project. GitHub provides a [good guide](https://help.github.com/en/github/building-a-strong-community/setting-guidelines-for-repository-contributors) for adding a contributing file to your project. Note that these three files are created automatically if you use the Cookiecutter template from Section [2.1 Use Cookiecutter & Poetry to create a Python project](#pkg-docs) of [The Whole Game chapter](#whole-game).

## Code documentation {#code-documentation}

Code documentation is the practice of adding human-readable descriptions to your code. Efficient and proper code documentation is important to help others understand how your code works, why it works, for identifying bugs and maintaining and extending functionality. Code documentation can be split into two main categories: 

- **comments**: text within your code that is used to clarify what the code is doing and why.
- **docstrings**: the first statement in a module, function, class, or method definition that describes what the code does and may include defintions of arguments, example usage, and/or other important notes.

### Comments

Commenting convention in Python is described in [PEP 8 - Style Guide for Python Code](https://www.python.org/dev/peps/pep-0008/#comments). Your code comments will typically be inline or block comments. 

Inline comments are placed on the same line as your code. They start with a `#` and should be preceded by at least two spaces. They should also start with a single space. Inline comments should not be unnecessarily verbose, or simply state the obvious as this can be distracting and make your code more difficult to read. We will continue to build upon the `foocat` package and `catbind()` function that has been developed throughout this book to illustrate documentation in this chapter. An example of some inline comments are shown below.

```{python inline-comments, eval = FALSE}
def catbind(a, b):
    """
    Triple-quotes are used for docstrings which are discussed in the next section.
    """
    if not all(isinstance(x, pd.Categorical) for x in (a, b)):  # check that both input arguments are pandas categoricals
        raise TypeError("Inputs should be of type 'Pandas categorical'.")

    concatenated = pd.concat([pd.Series(a.astype("str")),
                              pd.Series(b.astype("str"))])
    return pd.Categorical(concatenated)
```

Block comments are paragraph-like text used to provide a more detailed description of your code. They typically precede the code they describe and should be used sparingly to avoid making your code overly verbose. Each line of a block comment should start with a `#` and a single space and should be indented to the same level as the code it precedes. A line containing a single `#` is used as a line break to split up multi-paragraph block comments. Despite common usage, triple-quotes should not be used for block comments - they are used for docstrings as described in the next section;

```{python block-comments, eval = FALSE}
def catbind(a, b):
    """
    Triple-quotes are used for docstrings which are discussed in the next section.
    """
    if not all(isinstance(x, pd.Categorical) for x in (a, b)):  # check both inputs are categoricals
        raise TypeError("Inputs should be of type 'Pandas categorical'.")
    # Coerce categorical to strings, then Pandas series, so that they can be concatenated
    # with pd.concat()
    concatenated = pd.concat([pd.Series(a.astype("str")),
                              pd.Series(b.astype("str"))])
    return pd.Categorical(concatenated)
```

### Docstrings

General docstring convention in Python is described in [PEP 257 - Docstring Conventions](https://www.python.org/dev/peps/pep-0257/).Docstrings are documentation included as the first statement in a module, function, class, or method in Python. Docstrings in Python are surrounded by triple-quotes, but other than that, there is flexibility in how you write your docstring. There are many different docstring style conventions used in Python. The exact style you use is important for helping you to render your documentation locally and remotely (more on that in the next section). The main styles currently in use are restructured text/sphinx style, google style, and numpy style. Examples of each of these styles can be found [here](https://sphinxcontrib-napoleon.readthedocs.io/en/latest/index.html). Presently, we recommend the use of numpy-style documentation strings due to their readability and prevalance in many open-source Python projects.

Numpy style docstrings are described in detail in the [numpydoc docstring guide](https://numpydoc.readthedocs.io/en/latest/format.html#docstring-standard). From that link, you will see that there is a wide range of information you can include in your docstring, however, the majority of docstrings you will write will comprise the following sections:

1. A one-line summary that does not use variable names or the function name;
2. An extended description/summary;
3. Parameter definitions and descriptions;
4. Returned value defintions and descriptions;
5. Example usage.

An example of the numpy docstring style is shown below. Note that there is specific syntax and spacing for defining each element of your documentation - although most of the time, you will simply be copy-pasting docstring templates and won't need to worry about remembering every detail. Also each of the above elements is denoted by `(#)` in the docstring for demonstration purposes only, these are not part of the docstring:

```{python docstring-style, eval = FALSE}
import pandas as pd


def catbind(a, b):
    """Concatenates two pandas categoricals. (1)
    
    Concatenates categorical `b` to categorical `a` and returns
    the resultant categorical. (2)
    
    Parameters (3)
    ----------
    a : pandas.core.arrays.categorical.Categorical
      A pandas categorical.
    b : pandas.core.arrays.categorical.Categorical
      A pandas categorical that you wish to concatenate to a.

    Returns (4)
    -------
    pandas.core.arrays.categorical.Categorical
      The new concatenated pandas categorical.

    Examples (5)
    --------
    >>> from foocat import foocat
    >>> a = pd.Categorical(["character", "hits", "your", "eyeballs"])
    >>> b = pd.Categorical(["but", "integer", "where it", "counts"])
    >>> foocat.catbind(a, b)
    [character, hits, your, eyeballs, but, integer, where it, counts]
    Categories (8, object): [but, character, counts,
    eyeballs, hits, integer, where it, your]
    """
    if not all(isinstance(x, pd.Categorical) for x in (a, b)):  # check both inputs are categoricals
        raise TypeError("Inputs should be of type 'Pandas categorical'.")
    # Coerce categorical to strings, then Pandas series, so that they can be concatenated
    # with pd.concat()
    concatenated = pd.concat([pd.Series(a.astype("str")),
                              pd.Series(b.astype("str"))])
    return pd.Categorical(concatenated)
```

## Rendering your documentation

### Locally

Now that you've gone to the effort of documenting your package and code, the next step is to combine this documentation into a clean, readable "document". This is important to help users explore and understand the functionality of your package without having to search through the source code. We will refer to this as documentation for the remainder of this section. [Sphinx](https://www.sphinx-doc.org/en/master/) is the main documentation generator used by the Python community (but note that it also works with, e.g., R, Java, PHP). Sphinx is based on reStructuredText, a lightweight markup language that works similar to Markdown but uses quite different syntax. reStructuredText appendix?

You can read the [Sphinx documentation](https://www.sphinx-doc.org/en/master/usage/installation.html) for help installing Sphinx but for the purpose of this section we will assume you are using poetry to help build your package. To add sphinx as a development dependency of your package we can run the following:

```
$ poetry add --dev sphinx
```

> Note the use of --dev to specify a development dependency, i.e., a package that is not required by a user to run you package, but is required to build your package.

Your documentation typically lives in a subdirectory called `docs` in the root package directory. At a minimum this `docs` subdirectory includes a `conf.py` file (which configure how Sphinx reads and builds your documentation) and `index.rst` file (a master document which serves as the "welcome page" of your documentation and acts as “table of contents” linking to the various parts of your documentation). The MDS Cookiecutter template that we downloaded and used in [The Whole Game chapter](#whole-game) automatically created this `docs` subdirectory for you, along with the `conf.py` and `index.rst` files. Some additional pre-populated files have also been included for you in this Cookiecutter including `background.rst`, `usage.rst`, `installation.rst`, `contributing.rst`, `contributors.rst`. If you don't want to use the MDS Cookiecutter to build this directory structure, you can see the [Sphinx documentation](https://www.sphinx-doc.org/en/master/usage/quickstart.html#) for help getting started.

We can build our documentation locally using the command:

```
$ poetry run make html
```

> Note 1: once again we precede the main command with "poetry run", as we have done throughout this book, to ensure we remain in the poetry virtual environment of our package.

> Note 2: we are building html renders of our documentation here, which is what you will usually want. However other formatd are available too, such as pdf. See the [Sphinx documentation for more](https://www.sphinx-doc.org/en/master/usage/quickstart.html#running-the-build).

This builds our base documentation. You can modify your docs as much as you like, but remember that you should write them in restrcutredtext. While it is possible to link to files outside of the `docs` directory, and even parse files that are not .rst format (such as .md files) with Sphinx - things start to get a little bit hacky and we recommend sticking with this vanilla Sphinx workflow. If you want to link to files such as images in your documentation, a common approach is to create a subdirectory called `_static` in the `docs` directory within which your files are placed and referenced to.

---

If we click on the “Module Index” link under the heading “Indices and tables” we get a “Your file was not found message”: This is because we haven’t written any documentation for our package function. Let’s do that now by adding a numpy-style docstring to the catbind function in foocat/foocat.py as shown below: Now we can use a sphinx extension (napolean) in combination with autodoc to render our numpy-styled docstring into a modules page on our docs. To do this we need to install another dev dependency:

https://ubc-mds.github.io/py-pkgs/whole-game.html#local-docs

Make html will make the docs for you (cna also do pdf, etc). This will create the general structure and basic information of your docs, but we want to get the docs of all our objects, i.e., the docstrings. We did not write our docstings as restructured text, we used the numpy style. So we need to convert this to restructured text so that sphinx can render it. Luckily we have an extension for this (https://sphinxcontrib-napoleon.readthedocs.io/en/latest/).

The Python packaging ecosystem has a tool to help you make this process more efficient - Sphinx. In the Cookiecutter template we provided you to set-up this package, there is a basic docs template that the Cookiecutter progam filled in with the information you entered interactively when you ran cookiecutter https://github.com/UBC-MDS/cookiecutter-ubc-mds.git. These files live in the doc directory and are .rst (reStructuredText markup language) filetype. This is a lightweight markup language that works similar to Markdown but uses different syntax. The templates provided to you here are fairly well formatted already, so you do not have to change the .rst formatting, however if you are interested in doing so, you can see this CheatsSheet to get started.

First, we need to install sphinx as a development dependency using poetry.

### Remotely

Use readthedocs