# The Whole Game {#whole-game}

This chapter demonstrates how to develop an entire small toy Python package from beginning to end. It's purpose it to motivate and give a high level overview of how a Python package can and should be developed. Later chapters will delve deeper into important package specifics. This chapter is a Pythonified version of [the Whole Game chapter](https://r-pkgs.org/whole-game.html) written by Jenny Bryan that can be found in the the [R packages book](https://r-pkgs.org/).

## Use Poetry to create a Python project {#poetry-to-create-project}

To create a new Python project with Poetry named `foo-categoricals`, using the terminal navigate to the parent directory that you wish the project directory to live in and type:

```{python create-project-fake, eval = FALSE}
$ poetry new foocategoricals
```

```
Created package foocategoricals in foocategoricals
```

When we do this, Poetry creates a directory with the following structure:

```
foocategoricals
â”œâ”€â”€ README.md
â”œâ”€â”€ foocategoricals
â”‚   â””â”€â”€ __init__.py
â”œâ”€â”€ pyproject.toml
â””â”€â”€ tests
    â”œâ”€â”€ __init__.py
    â””â”€â”€ test_foocategoricals.py
```

It gives us a boilerplate file and directory structure suitable for building a Python package, including a file for us to write out Python functions that our package will distribute (`foocategoricals/__init__.py`), a home for our tests to ensure that our package functions work as we expect they should (`tests/__init__.py`), as well as a `pyproject.toml` file that we will use to define our project's metadata.

> **Optional for RStudio IDE users**
> Users of the RStudio IDE may also want to make this Python project directory an RStudio project. Why might you ask? Well, once you have an `*.Rproj` file, you can use that file to quickly open the RStudio IDE (which has a terminal and an interactive Python REPL, assuming you have set this up with `reticulate`) to the project's root directory.

## Put your project under version control {#versio-control}

It is in our opinion that every data science project should put under local and remote version control. The tools we recommend using for this are Git & GitHub. For this book, we assume Git is installed on their machine, have novice Git skills, and that users have a [GitHub.com](https://github.com/) account.

### Set-up local version control

From the terminal and in the root of this project directory, initialize the repository to be tracked by Git:

```
$ git init
```

```
Initialized empty Git repository in /Users/tiffany/Documents/ubc-mds/foocategoricals/.git/
```

Next, tell Git which files to track (all of them at this point) and commit these changes locally:

```
$ git add .
$ git commit -m "initial project set-up"
```

```
[master (root-commit) 00bc4af] initial project set-up
 7 files changed, 35 insertions(+)
 create mode 100644 .gitignore
 create mode 100644 README.rst
 create mode 100644 foocategoricals.Rproj
 create mode 100644 foocategoricals/__init__.py
 create mode 100644 pyproject.toml
 create mode 100644 tests/__init__.py
 create mode 100644 tests/test_foocategoricals.py
```

> **Optional for RStudio IDE users**
> You may want to create a `.gitignore` file where you tell Git to ignore RStudio-specific files such as `.Rproj.user` and `foocategoricals.Rproj` that are typically not found in a Python package.


### Set-up remote version control

Now that we have set up our local version control, let's create a repository on [GitHub.com](https://github.com/) and set that as the remote version control home for this project:

<img src="img/set-up-github1.png">

The options we recommend for setting up a repository for a Python package using the workflow we present in this book include: 

- give the GitHub.com repository the same name as your Python Poetry project's name
- make the GitHub.com repository public
- **do not** initialize the GitHub.com repository with a README

<img src="img/set-up-github2.png" >

Next, we set-up the remote address locally, and push our project to GitHub.com:

```
$ git remote add origin git@github.com:ttimbers/foocategoricals.git
$ git push -u origin master
```

> Note: the example above uses SSH authentication with GitHub, HTTPS authentication works as well and would use this url in place of the one shown above to set the remote: `https://github.com/ttimbers/foocategoricals.git`.

## Write the first function {#first-function}

Pandas categoricals are a very useful datatype for modeling (and were inspired by R's factors), but certain manipulations of this data type can be tricky in data wrangling. One such challenge is concatenation of Pandas categoricals. Let's observe the result of trying to concatenate two Pandas categoricals objects:

```{python cat-pandas-cat-error, error = TRUE}
import pandas as pd

a = pd.Categorical(["character", "hits", "your", "eyeballs"])
b = pd.Categorical(["but", "integer", "where it", "counts"])

pd.concat([a, b])
```

This occurs because the categoricals are represented as integers in memory, and in `a` the integer 0 corresponds to the word "character" while in `b`, the integer 0 corresponds to the word "but". Thus, when we ask Python to concatenate these two Pandas categorical options it doesn't know what to do with these integer mappings to different categories, and so it throws an error. We can get around this several ways, one way is to convert the Pandas categoricals to a `str` type, then do the concatenation, and finally convert the concatenated Pandas obeject to a categorical again. We demonstrate that approach below:

```{python cat-pandas-cat}
concatenated = pd.concat([pd.Series(a.astype("string")), pd.Series(b.astype("string"))])
pd.Categorical(concatenated)
```

That seems to work ðŸŽ‰, but its quite a bit of typing everytime we want to do this... Let's turn this into a function called `catbind`!

```{python cat-pandas-cat-function}
def catbind(a, b):
  concatenated = pd.concat([pd.Series(a.astype("string")), pd.Series(b.astype("string"))])
  return pd.Categorical(concatenated)
```

> Note - this book assumes you know how to write, document and test functions in Python. To learn more about this see [Think Python, Chapter 3: Functions](http://greenteapress.com/thinkpython/html/thinkpython004.html) by Allen Downey.

Where do we save this function if we want it to be a part of our foocategorical Python package? Let's review the landscape of our Python project so far:

```
foocategoricals
â”œâ”€â”€ README.md
â”œâ”€â”€ foocategoricals
â”‚   â””â”€â”€ __init__.py
â”œâ”€â”€ pyproject.toml
â””â”€â”€ tests
    â”œâ”€â”€ __init__.py
    â””â”€â”€ test_foocategoricals.py
```

All the code that we would like the user to run as part of our package should live inside the `foocategoricals` directory. Typically, inside this directory, we would create a sub-directory containing a python script to house the function. Let's do that now:

First we create a subdirectory inside foocategoricals called `cat` using `mkdir` in the terminal:

```
$ mkdir foocategoricals/cat
```

> Note: `mkdir` is a command in the bash shell that we can use to create new directories. You are welcome to create directories using the RStudio IDE, or your computer's OS if you prefer that workflow.

Next we create a python script called `cat.py` that lives inside the cat directory and save our `catbind` function there. Our project directory structure should now look like this:

```
foocategoricals
â”œâ”€â”€ README.md
â”œâ”€â”€ foocategoricals
â”‚   â”œâ”€â”€ __init__.py
|   â””â”€â”€ cat
|       â”œâ”€â”€ cat.py
â”œâ”€â”€ pyproject.toml
â””â”€â”€ tests
    â”œâ”€â”€ __init__.py
    â””â”€â”€ test_foocategoricals.py
```

Now, inside `foocategoricals/__init__.py` we need to add one line of Python code (below the line of code that Poetry wrote there when we set up the project, which is something like `__version__ = '0.1.0'`) to import the `catbind` function from `cat.py`:

```
from cat.cat import catbind
```

TO DO: deal with Pandas dependency




