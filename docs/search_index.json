["whole-game.html", "Chapter 3 The Whole Game 3.1 Use Cookiecutter &amp; Poetry to create a Python project 3.2 Put your project under version control 3.3 Write the first function 3.4 Test drive your package code", " Chapter 3 The Whole Game This chapter demonstrates how to develop an entire small toy Python package from beginning to end. It‚Äôs purpose it to motivate and give a high level overview of how a Python package can and should be developed. Later chapters will delve deeper into important package specifics. This chapter is a Pythonified version of the Whole Game chapter written by Jenny Bryan that can be found in the the R packages book. 3.1 Use Cookiecutter &amp; Poetry to create a Python project So that we do not have to create a complicated file and directory structure ourselves, we will use Cookiecutter &amp; Poetry to do this for us! First we start with using Cookiecutter to create the project file and directory structure for our Python project (which will be a Python package). We will use a simplified version of the template base by the PyOpenSci organization designed specifically for creating Python packages. PyOpenSci is a not-for-profit organization that promotes open and reproducible research through peer-review of scientific Python packages. To use Cookiecutter to set up the structure of your Python package, run the line of code below in the terminal from the directory where you would like your package to live. $ cookiecutter https://github.com/UBC-MDS/cookiecutter-pyopensci.git You will be prompted to provide information that will help customize the project. Here is a example of how to respond the the prompts: full_name [Audrey Roy Greenfeld]: Tiffany Timbers email [audreyr@example.com]: tiffany.timbers@stat.ubc.ca github_username [audreyr]: ttimbers project_name [Python Boilerplate]: foocategoricals project_slug [foocategoricals]: foocategoricals project_short_description [Python Boilerplate contains all the boilerplate you need to create a Python package.]: Python package that eases the pain concatenating Pandas categoricals! pypi_username [ttimbers]: ttimbers version [0.1.0]: 0.1.0 use_pypi_deployment_with_travis [n]: n add_pyup_badge [n]: n Select open_source_license: 1 - MIT license 2 - BSD license 3 - ISC license 4 - Apache Software License 2.0 5 - GNU General Public License v3 Choose from 1, 2, 3, 4, 5 [1]: 1 Next we initialize the project as a Poetry project so that we can take advantage of the package management and building tools provided by Poetry: $ poetry init foocategoricals Again we are prompted for more information. We are provided with some suggestions for the information (which I think is gleaned from the Cookiecutter template that we just set up), and if we agree we can simply click enter at the prompt. Here is a example of how to respond the the prompts: This command will guide you through creating your pyproject.toml config. Package name [foocategoricals]: Version [0.1.0]: Description []: Python package that eases the pain concatenating Pandas categoricals! Author [ttimbers &lt;tiffany.timbers@stat.ubc.ca&gt;, n to skip]: License []: MIT Compatible Python versions [^3.7]: Would you like to define your main dependencies interactively? (yes/no) [yes] no Would you like to define your dev dependencies (require-dev) interactively (yes/no) [yes] no Generated file [tool.poetry] name = &quot;foocategoricals&quot; version = &quot;0.1.0&quot; description = &quot;Python package that eases the pain concatenating Pandas categoricals!&quot; authors = [&quot;ttimbers &lt;tiffany.timbers@stat.ubc.ca&gt;&quot;] license = &quot;MIT&quot; [tool.poetry.dependencies] python = &quot;^3.7&quot; [tool.poetry.dev-dependencies] [build-system] requires = [&quot;poetry&gt;=0.12&quot;] build-backend = &quot;poetry.masonry.api&quot; Do you confirm generation? (yes/no) [yes] yes (base) dhcp-206-87-122-46:foocategoricals tiffany$ poerty build bash: poerty: command not found (base) dhcp-206-87-122-46:foocategoricals tiffany$ poetry build Creating virtualenv foocategoricals-lqqH1SDF-py3.7 in /Users/tiffany/Library/Caches/pypoetry/virtualenvs Building foocategoricals (0.1.0) - Building sdist - Built foocategoricals-0.1.0.tar.gz - Building wheel - Built foocategoricals-0.1.0-py3-none-any.whl After using Cookiecutter and Poetry, we end up with the following directory structure: foocategoricals ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ foocategoricals ‚îÇ ‚îî‚îÄ‚îÄ __init__.py ‚îú‚îÄ‚îÄ pyproject.toml ‚îî‚îÄ‚îÄ tests ‚îú‚îÄ‚îÄ __init__.py ‚îî‚îÄ‚îÄ test_foocategoricals.py It gives us a boilerplate file and directory structure suitable for building a Python package, including a file for us to write out Python functions that our package will distribute (foocategoricals/__init__.py), a home for our tests to ensure that our package functions work as we expect they should (tests/__init__.py), as well as a pyproject.toml file that we will use to define our project‚Äôs metadata. Optional for RStudio IDE users Users of the RStudio IDE may also want to make this Python project directory an RStudio project. Why might you ask? Well, once you have an *.Rproj file, you can use that file to quickly open the RStudio IDE (which has a terminal and an interactive Python REPL, assuming you have set this up with reticulate) to the project‚Äôs root directory. 3.2 Put your project under version control It is in our opinion that every data science project should put under local and remote version control. The tools we recommend using for this are Git &amp; GitHub. For this book, we assume Git is installed on their machine, have novice Git skills, and that users have a GitHub.com account. 3.2.1 Set-up local version control From the terminal and in the root of this project directory, initialize the repository to be tracked by Git: $ git init Initialized empty Git repository in /Users/tiffany/Documents/ubc-mds/foocategoricals/.git/ Next, tell Git which files to track (all of them at this point) and commit these changes locally: $ git add . $ git commit -m &quot;initial project set-up&quot; [master (root-commit) 00bc4af] initial project set-up 7 files changed, 35 insertions(+) create mode 100644 .gitignore create mode 100644 README.rst create mode 100644 foocategoricals.Rproj create mode 100644 foocategoricals/__init__.py create mode 100644 pyproject.toml create mode 100644 tests/__init__.py create mode 100644 tests/test_foocategoricals.py Optional for RStudio IDE users You may want to create a .gitignore file where you tell Git to ignore RStudio-specific files such as .Rproj.user and foocategoricals.Rproj that are typically not found in a Python package. 3.2.2 Set-up remote version control Now that we have set up our local version control, let‚Äôs create a repository on GitHub.com and set that as the remote version control home for this project: The options we recommend for setting up a repository for a Python package using the workflow we present in this book include: give the GitHub.com repository the same name as your Python Poetry project‚Äôs name make the GitHub.com repository public do not initialize the GitHub.com repository with a README Next, we set-up the remote address locally, and push our project to GitHub.com: $ git remote add origin git@github.com:ttimbers/foocategoricals.git $ git push -u origin master Note: the example above uses SSH authentication with GitHub, HTTPS authentication works as well and would use this url in place of the one shown above to set the remote: https://github.com/ttimbers/foocategoricals.git. 3.3 Write the first function Pandas categoricals are a very useful datatype for modeling (and were inspired by R‚Äôs factors), but certain manipulations of this data type can be tricky in data wrangling. One such challenge is concatenation of Pandas categoricals. Let‚Äôs observe the result of trying to concatenate two Pandas categoricals objects: &gt;&gt;&gt; import pandas as pd &gt;&gt;&gt; a = pd.Categorical([&quot;character&quot;, &quot;hits&quot;, &quot;your&quot;, &quot;eyeballs&quot;]) &gt;&gt;&gt; b = pd.Categorical([&quot;but&quot;, &quot;integer&quot;, &quot;where it&quot;, &quot;counts&quot;]) &gt;&gt;&gt; pd.concat([a, b]) ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: cannot concatenate object of type &#39;&lt;class &#39;pandas.core.arrays.categorical.Categorical&#39;&gt;&#39;; only Series and DataFrame objs are valid ## ## Detailed traceback: ## File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; ## File &quot;/opt/anaconda3/lib/python3.7/site-packages/pandas/core/reshape/concat.py&quot;, line 281, in concat ## sort=sort, ## File &quot;/opt/anaconda3/lib/python3.7/site-packages/pandas/core/reshape/concat.py&quot;, line 357, in __init__ ## raise TypeError(msg) This occurs because the categoricals are represented as integers in memory, and in a the integer 0 corresponds to the word ‚Äúcharacter‚Äù while in b, the integer 0 corresponds to the word ‚Äúbut‚Äù. Thus, when we ask Python to concatenate these two Pandas categorical options it doesn‚Äôt know what to do with these integer mappings to different categories, and so it throws an error. We can get around this several ways, one way is to convert the Pandas categoricals to a str type, then do the concatenation, and finally convert the concatenated Pandas obeject to a categorical again. We demonstrate that approach below: &gt;&gt;&gt; concatenated = pd.concat([pd.Series(a.astype(&quot;string&quot;)), pd.Series(b.astype(&quot;string&quot;))]) &gt;&gt;&gt; pd.Categorical(concatenated) ## [character, hits, your, eyeballs, but, integer, where it, counts] ## Categories (8, object): [but, character, counts, eyeballs, hits, integer, where it, your] That seems to work üéâ, but its quite a bit of typing everytime we want to do this‚Ä¶ Let‚Äôs turn this into a function called catbind! def catbind(a, b): concatenated = pd.concat([pd.Series(a.astype(&quot;string&quot;)), pd.Series(b.astype(&quot;string&quot;))]) return pd.Categorical(concatenated) catbind(a, b) ## [character, hits, your, eyeballs, but, integer, where it, counts] ## Categories (8, object): [but, character, counts, eyeballs, hits, integer, where it, your] Note - this book assumes you know how to write, document and test functions in Python. To learn more about this see Think Python, Chapter 3: Functions by Allen Downey. Where do we save this function if we want it to be a part of our foocategorical Python package? Let‚Äôs review the landscape of our Python project so far: foocategoricals ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ foocategoricals ‚îÇ ‚îî‚îÄ‚îÄ __init__.py ‚îú‚îÄ‚îÄ pyproject.toml ‚îî‚îÄ‚îÄ tests ‚îú‚îÄ‚îÄ __init__.py ‚îî‚îÄ‚îÄ test_foocategoricals.py All the code that we would like the user to run as part of our package should live inside the foocategoricals directory. Typically, inside this directory, we would create a sub-directory containing a python script to house the function. Let‚Äôs do that now: First we create a subdirectory inside foocategoricals called cat using mkdir in the terminal: $ mkdir foocategoricals/cat Note: mkdir is a command in the bash shell that we can use to create new directories. You are welcome to create directories using the RStudio IDE, or your computer‚Äôs OS if you prefer that workflow. Next we create a python script called cat.py that lives inside the cat directory and save our catbind function there. Our project directory structure should now look like this: foocategoricals ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ foocategoricals ‚îÇ ‚îú‚îÄ‚îÄ __init__.py | ‚îî‚îÄ‚îÄ cat | ‚îú‚îÄ‚îÄ cat.py ‚îú‚îÄ‚îÄ pyproject.toml ‚îî‚îÄ‚îÄ tests ‚îú‚îÄ‚îÄ __init__.py ‚îî‚îÄ‚îÄ test_foocategoricals.py Given that our package depends on the Pandas Python package, we should import Pandas at the top of the cat.py file. here‚Äôs what cat.py should now look like: import pandas as pd def catbind(a, b): concatenated = pd.concat([pd.Series(a.astype(&quot;string&quot;)), pd.Series(b.astype(&quot;string&quot;))]) return pd.Categorical(concatenated) 3.4 Test drive your package code To test drive the function we just wrote we can import it into an interactive Python session as shown: &gt;&gt;&gt; from foocategoricals.cat import cat By doing this we can access the the function in our Python session via cat.catbind. Let‚Äôs now try to use this function to concatenate two Pandas categoricals: &gt;&gt;&gt; import pandas as pd &gt;&gt;&gt; a = pd.Categorical([&quot;character&quot;, &quot;hits&quot;, &quot;your&quot;, &quot;eyeballs&quot;]) &gt;&gt;&gt; b = pd.Categorical([&quot;but&quot;, &quot;integer&quot;, &quot;where it&quot;, &quot;counts&quot;]) &gt;&gt;&gt; cat.catbind(a, b) [character, hits, your, eyeballs, but, integer, where it, counts] Categories (8, object): [but, character, counts, eyeballs, hits, integer, where it, your] Hurray again! This seems to work as expected! "]